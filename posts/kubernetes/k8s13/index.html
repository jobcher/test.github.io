<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link media="all" rel="stylesheet" href="/css/style.css">

<script src="/js/style.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>

    <title>Kubernetes — 探针和生命周期</title>
</head>

<body>
    <div class="header-box">
    <img src="https://test.jobcher.com/images/logo.webp" id="logo" alt="logo" class="logo">
    <h1><a href="https://test.jobcher.com">打工人日志</a></h1>
</div>
<nav class="nav">
    <ul>
        
            <li>
                <a href="/">首页</a>
                
            </li>
        
            <li>
                <a href="/posts">文章</a>
                
            </li>
        
            <li>
                <a href="https://nav.jobcher.com/">导航</a>
                
            </li>
        
            <li>
                <a href="/posts/about">关于</a>
                
            </li>
        
    </ul>
</nav>
    <div id="post" class="post">
        <header>
            <h2 class="post-title">Kubernetes — 探针和生命周期</h2>
            
        </header>
        <article class="article">
                <div class="single-content">
                    <h1 id="kubernetes--探针和生命周期">Kubernetes — 探针和生命周期</h1>
<p>用于判断容器内应用程序是否已经启动。</p>
<ul>
<li>存活（Liveness）探针
<ul>
<li>用于探测容器是否运行，如果探测失败，kubelet 会根据配置的重启策略进行相应的处理，若没有配置探针该返回值默认为 success</li>
</ul>
</li>
<li>就绪（Readiness）探针
<ul>
<li>用于探测容器内的程序是否健康，如果返回值为 success，那么代表这个容器已经完全启动，并且程序已经是可以接受流量的状态</li>
</ul>
</li>
<li>启动（Startup）探针
<ul>
<li>用于探测容器是否启动，如果配置了 startup 就会先禁止其他探测，直到它成功，成功后将不在运行探测</li>
</ul>
</li>
</ul>
<h2 id="pod-检测方式">Pod 检测方式</h2>
<ul>
<li>ExecAction：在容器执行一个命令，返回值为 0，则认为容器健康</li>
<li>TCPSocketAction：通过 TCP 连接检查容器是否联通，通的话，则认为容器正常</li>
<li>HTTPGetAction：通过应用程序暴露的 API 地址来检查程序是否正常的，如果状态码为 200-400 之间，则认为容器健康</li>
<li>gRPCAction：通过 gRPC 的检查机制，判断容器是不是正常</li>
</ul>
<h2 id="startupprobe-启动探针">StartupProbe 启动探针</h2>
<p>有时候，会有一些现有的应用在启动时需要<code>较长的初始化时间</code>。 要这种情况下，若要不影响对<code>死锁</code>作出快速响应的探测，设置存活探测参数是要技巧的。 技巧就是使用相同的命令来设置启动探测，针对 HTTP 或 TCP 检测，可以通过将 <code>failureThreshold * periodSeconds</code> 参数设置为足够长的时间来应对糟糕情况下的启动时间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">liveness-port</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">hostPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">httpGet</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/healthz</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">liveness-port</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">failureThreshold</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">startupProbe</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">httpGet</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/healthz</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">liveness-port</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">failureThreshold</span>: <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">10</span>
</span></span></code></pre></div><p>幸亏有启动探测，应用程序将会有最多 <code>5 分钟（30 * 10 = 300s）</code>的时间来完成其启动过程。 一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁作出快速响应。 如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据<code>restartPolicy</code>来执行进一步处置。</p>
<h2 id="livenessprobe-存活探针">LivenessProbe 存活探针</h2>
<h3 id="execaction">ExecAction</h3>
<p>许多长时间运行的应用最终会进入损坏状态，除非重新启动，否则无法被恢复。 <code>Kubernetes</code> 提供了存活探针来发现并处理这种情况。<br>
在本练习中，你会创建一个 <code>Pod</code>，其中运行一个基于 <code>registry.k8s.io/busybox</code> 镜像的容器。 下面是这个 <code>Pod</code> 的配置文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">test</span>: <span style="color:#ae81ff">liveness</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">liveness-exec</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">liveness</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/busybox</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">/bin/sh</span>
</span></span><span style="display:flex;"><span>        - -<span style="color:#ae81ff">c</span>
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">exec</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">command</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">cat</span>
</span></span><span style="display:flex;"><span>            - <span style="color:#ae81ff">/tmp/healthy</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>在这个配置文件中，可以看到 <code>Pod</code> 中只有一个 <code>Container</code>。 <code>periodSeconds</code> 字段指定了 <code>kubelet</code> 应该每 <code>5</code> 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 <code>kubelet</code> 在执行第一次探测前应该等待 <code>5</code> 秒。 kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。 如果命令执行成功并且返回值为 <code>0</code>，<code>kubelet</code> 就会认为这个容器是健康存活的。 如果这个命令返回<code>非 0</code> 值，<code>kubelet</code> 会杀死这个容器并重新启动它。</p>
<p>当容器启动时，执行如下的命令：</p>
<blockquote>
<p>/bin/sh -c &ldquo;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&rdquo;</p>
</blockquote>
<p>这个容器生命的前 30 秒，<code>/tmp/healthy</code> 文件是存在的。 所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。 30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。<br>
在 30 秒内，查看 Pod 的事件：</p>
<blockquote>
<p>kubectl describe pod liveness-exec</p>
</blockquote>
<h3 id="httpgetaction">HTTPGetAction</h3>
<p>另外一种类型的存活探测方式是使用 <code>HTTP GET</code> 请求。 下面是一个 <code>Pod</code> 的配置文件，其中运行一个基于 <code>registry.k8s.io/liveness</code> 镜像的容器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">test</span>: <span style="color:#ae81ff">liveness</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">liveness-http</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">liveness</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/liveness</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">args</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#ae81ff">/server</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">httpGet</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/healthz</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">httpHeaders</span>:
</span></span><span style="display:flex;"><span>            - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Custom-Header</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">value</span>: <span style="color:#ae81ff">Awesome</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>在这个配置文件中，你可以看到 <code>Pod</code> 也只有一个容器。 <code>periodSeconds</code> 字段指定了 <code>kubelet</code> 每隔 3 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 <code>kubelet</code> 在执行第一次探测前应该等待 3 秒。 <code>kubelet</code> 会向容器内运行的服务（服务在监听 <code>8080 端口</code>）发送一个 <code>HTTP GET</code> 请求来执行探测。 如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 <code>kubelet</code> 认为容器是健康存活的。 如果处理程序返回失败代码，则 <code>kubelet</code> 会杀死这个容器并将其重启。</p>
<p>返回大于或等于 <code>200</code> 并且小于 <code>400</code> 的任何代码都标示成功，其它返回代码都标示失败。</p>
<p>你可以访问 <code>server.go</code>。 阅读服务的源码。 容器存活期间的最开始 <code>10 秒中</code>，<code>/healthz</code> 处理程序返回 <code>200</code> 的状态码。 之后处理程序返回 <code>500</code> 的状态码。</p>
<h3 id="tcpsocketaction">TCPSocketAction</h3>
<p>第三种类型的存活探测是使用 <code>TCP 套接字</code>。 使用这种配置时，<code>kubelet</code> 会尝试在指定端口和容器建立套接字链接。 如果<code>能建立连接</code>，这个容器就被看作是<code>健康</code>的，如果<code>不能</code>则这个容器就被看作是<code>有问题</code>的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">goproxy</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">goproxy</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">goproxy</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/goproxy:0.1</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">readinessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">tcpSocket</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">tcpSocket</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">20</span>
</span></span></code></pre></div><p>如是汝闻，<code>TCP 检测</code>的配置和 <code>HTTP 检测</code>非常相似。 下面这个例子同时使用就绪和存活探针。<code>kubelet</code> 会在容器启动 <code>5 秒</code>后发送第一个就绪探针。 探针会尝试连接 <code>goproxy</code> 容器的 8080 端口。 如果探测成功，这个 <code>Pod</code> 会被标记为就绪状态，kubelet 将继续每隔 <code>10 秒</code>运行一次探测。</p>
<p>除了就绪探针，这个配置包括了一个存活探针。 <code>kubelet</code> 会在容器启动 <code>15 秒</code>后进行第一次存活探测。 与就绪探针类似，存活探针会尝试连接 <code>goproxy 容器</code>的 <code>8080 端口</code>。 如果存活探测失败，容器会被重新启动。</p>
<h3 id="grpcaction">gRPCAction</h3>
<p>如果你的应用实现了 gRPC 健康检查协议， <code>kubelet</code> 可以配置为使用该协议来执行应用存活性检查。 你必须启用 <code>GRPCContainerProbe</code> 特性门控 才能配置依赖于 <code>gRPC 的检查机制</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">etcd-with-grpc</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">etcd</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/etcd:3.5.1-0</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">command</span>:
</span></span><span style="display:flex;"><span>        [
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;/usr/local/bin/etcd&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--data-dir&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;/var/lib/etcd&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--listen-client-urls&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;http://0.0.0.0:2379&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--advertise-client-urls&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;http://127.0.0.1:2379&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--log-level&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;debug&#34;</span>,
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">2379</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">livenessProbe</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">grpc</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">port</span>: <span style="color:#ae81ff">2379</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">10</span>
</span></span></code></pre></div><p>要使用 <code>gRPC 探针</code>，必须<code>配置 port 属性</code>。如果健康状态端点配置在非默认服务之上， 你还必须设置 <code>service 属性</code>。</p>
<p>在 <code>Kubernetes 1.23</code> 之前，<code>gRPC 健康探测</code>通常使用 <code>grpc-health-probe</code> 来实现，如博客 <code>Health checking gRPC servers on Kubernetes</code>（对 <code>Kubernetes</code> 上的 <code>gRPC 服务器</code>执行健康检查）所描述。 内置的 <code>gRPC 探针</code>行为与 <code>grpc-health-probe</code> 所实现的行为类似。 从 <code>grpc-health-probe</code> 迁移到内置探针时，请注意以下差异：</p>
<p>内置探针运行时针对的是 Pod 的 IP 地址，不像 <code>grpc-health-probe</code> 那样通常针对 127.0.0.1 执行探测； 请一定配置你的 gRPC 端点使之监听于 Pod 的 IP 地址之上。
内置探针不支持任何身份认证参数（例如 -tls）。
对于内置的探针而言，不存在错误代码。所有错误都被视作探测失败。
如果 <code>ExecProbeTimeout</code> 特性门控被设置为 <code>false</code>，则 <code>grpc-health-probe</code> 不会考虑 <code>timeoutSeconds</code> 设置状态（默认值为 1s）， 而内置探针则会在超时时返回失败。</p>
<h2 id="readinessprobe-就绪探针">ReadinessProbe 就绪探针</h2>
<p>有时候，应用会暂时性地无法为请求提供服务。 例如，应用在启动时可能需要加载大量的数据或配置文件，或是启动后要依赖等待外部服务。 在这种情况下，<code>既不想杀死应用</code>，也不想给它发送请求。 <code>Kubernetes</code> 提供了就绪探针来发现并缓解这些情况。 容器所在 Pod 上报还未就绪的信息，并且不接受通过 <code>Kubernetes Service</code> 的流量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yml" data-lang="yml"><span style="display:flex;"><span><span style="color:#f92672">readinessProbe</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">exec</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">command</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">cat</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ae81ff">/tmp/healthy</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">initialDelaySeconds</span>: <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">periodSeconds</span>: <span style="color:#ae81ff">5</span>
</span></span></code></pre></div>
                </div>
            <br />
        <div>
                
                <a href="https://test.jobcher.com/posts/kubernetes/k8s15/" class="prev">前一页</a>
                
                
                <a href="https://test.jobcher.com/posts/monitoring/windows-exporter/" class="next">后一页</a>
                
            </div>
        </article>
    </div>

    <nav class="footer-nav">
        <ul>
            
            <li><a href="/posts/about">关于我们</a></li>
            
            <li><a href="/posts">博文合集</a></li>
            
            <li><a href="/">网站首页</a></li>
            
        </ul>
    </nav>
    <footer class="footer">
    <span style="color: aliceblue;">© 2019-2023 by jobcher</span>
</footer>
</body>

</html>