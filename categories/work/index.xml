<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>work on </title>
    <link>/categories/work/</link>
    <description>Recent content in work on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 30 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/work/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用scrapy-redis实现增量爬取</title>
      <link>/posts/work/scrapyredis/</link>
      <pubDate>Thu, 30 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/scrapyredis/</guid>
      <description>使用scrapy-redis实现增量爬取 Scrapy-Redis是Scrapy框架的一个插件，可以使用Redis实现Scrapy的分布式爬虫。它使用Redis作为分布式队列，可以轻松地将爬虫分布在多个机器上。同时，它还提供了一些功能，如去重、持久化、增量爬取等。
要使用Scrapy-Redis实现增量爬取，可以采取以下步骤： 在Scrapy项目中安装Scrapy-Redis插件。可以使用pip安装：pip install scrapy-redis 在Scrapy的settings.py中添加如下配置： # 使用Redis调度器 SCHEDULER = &amp;#34;scrapy_redis.scheduler.Scheduler&amp;#34; # 使用Redis去重过滤器 DUPEFILTER_CLASS = &amp;#34;scrapy_redis.dupefilter.RFPDupeFilter&amp;#34; # 允许暂停、恢复爬取 SCHEDULER_PERSIST = True 将Spider的爬取链接放入Redis队列中。可以在Spider中重载start_requests()方法，从Redis队列中获取链接开始爬取。 import scrapy from scrapy_redis.spiders import RedisSpider class MySpider(RedisSpider): name = &amp;#39;myspider&amp;#39; redis_key = &amp;#39;myspider:start_urls&amp;#39; def parse(self, response): # 处理响应 pass 在Spider中实现增量爬取。可以通过重载Spider中的start_requests()方法或者使用SpiderMiddleware来实现增量爬取。这里提供一种通过修改Redis队列来实现增量爬取的方法。 import scrapy import redis from scrapy_redis.spiders import RedisSpider from scrapy.utils.project import get_project_settings class MySpider(RedisSpider): name = &amp;#39;myspider&amp;#39; redis_key = &amp;#39;myspider:start_urls&amp;#39; redis_conn = None def __init__(self, *args, **kwargs): super(MySpider, self).</description>
    </item>
    
    <item>
      <title>Chrome浏览器启动参数大全（命令行参数）</title>
      <link>/posts/work/chrome/</link>
      <pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/chrome/</guid>
      <description>背景 在开发 Web 项目当中，浏览器必不可少，而浏览器的启动参数可以帮我们实现很多功能。
常用参数 序号 参数 说明 1 &amp;ndash;allow- ted-plugins 不停用过期的插件。 2 &amp;ndash;allow-running-insecure-content 默认情况下，https 页面不允许从 http 链接引用 javascript/css/plug-ins。添加这一参数会放行这些内容。 3 &amp;ndash;allow-scripting-gallery 允许拓展脚本在官方应用中心生效。默认情况下，出于安全因素考虑这些脚本都会被阻止。 4 &amp;ndash;disable-desktop-notifications 禁用桌面通知，在 Windows 中桌面通知默认是启用的。 5 &amp;ndash;disable-file-system 停用 FileSystem API。 6 &amp;ndash;disable-preconnect 停用 TCP/IP 预连接。 7 &amp;ndash;disable-remote-fonts 关闭远程字体支持。SVG 中字体不受此参数影响。 8 &amp;ndash;disable-web-security 不遵守同源策略。 9 &amp;ndash;disk-cache-dir 将缓存设置在给定的路径。 10 &amp;ndash;disk-cache-size 设置缓存大小上限，以字节为单位。 11 &amp;ndash;dns-prefetch-disable 停用 DNS 预读。 12 &amp;ndash;enable-print-preview 启用打印预览。 13 &amp;ndash;extensions-update-frequency 设定拓展自动更新频率，以秒为单位。 14 &amp;ndash;incognito 让浏览器直接以隐身模式启动。 15 &amp;ndash;keep-alive-for-test 最后一个标签关闭后仍保持浏览器进程。（某种意义上可以提高热启动速度，不过你最好得有充足的内存） 16 &amp;ndash;kiosk 启用 kiosk 模式。（一种类似于全屏的浏览模式） 17 &amp;ndash;lang 使用指定的语言。 18 &amp;ndash;no-displaying-insecure-content 默认情况下，https 页面允许从 http 链接引用图片/字体/框架。添加这一参数会阻止这些内容。 19 &amp;ndash;no-referrers 不发送 Http-Referer 头。 20 &amp;ndash;no-startup-window 启动时不建立窗口。 21 &amp;ndash;proxy-server 使用给定的代理服务器，这个参数只对 http 和 https 有效。 22 &amp;ndash;start-maximized 启动时最大化。 23 &amp;ndash;single-process 以单进程模式运行 Chromium。（启动时浏览器会给出不安全警告）。 24 &amp;ndash;user-agent 使用给定的 User-Agent 字符串。 25 &amp;ndash;process-per-tab 每个分页使用单独进程。 26 &amp;ndash;process-per-site 每个站点使用单独进程。 27 &amp;ndash;in-process-plugins 插件不启用单独进程。 28 &amp;ndash;disable-popup-blocking 禁用弹出拦截。 29 &amp;ndash;disable-javascript 禁用 JavaScript。 30 &amp;ndash;disable-java 禁用 Java。 31 &amp;ndash;disable-plugins 禁用插件。 32 –disable-images 禁用图像。 更多参数 由于水平有限，下表为网络翻译，了解跟多可根基参数，查找相关资料。 序号 参数 说明 1 &amp;ndash; 报告伪分配跟踪。伪跟踪从当前活动的跟踪事件派生。 2 &amp;ndash;/prefetch:1 /prefetch:启动各种流程类型时使用的＃arguments。已经观察到，当文件读取与具有相同/prefetch:＃参数的 3 个进程启动一致时，Windows 预取器开始在进程启动时批量发出读取。因为读取取决于进程类型，如果没有/prefetch:＃arguments 使用了预取器，则预取器将无法观察到一致的读取。请注意，浏览器进程没有/prefetch:＃参数; 因此，所有其他过程必须有一个，以避免污染其配置文件。注意:＃必须始终在[1,8]; 否则 Windows 预取器会忽略它。 3 &amp;ndash;/prefetch:5 /prefetch:在后台模式和观察程序进程中启动的浏览器进程的#refact。 4 &amp;ndash;/prefetch:8 Windows 预取程序使用预取参数来消除相同可执行映像的不同执行模式（即进程类型）的歧义，以便不同类型的进程不会践踏彼此的预取行为。合法值是[1,8]范围内的整数。我们保留 8 表示“无论什么”，这将最终导致具有/prefetch 的进程:8 具有不一致的行为，因此在实践中禁用预取。TODO（rockot）:使嵌入器能够在每个服务的基础上覆盖此参数。 5 &amp;ndash;accept-resource-provider 指示必须设置资源提供程序以向投射接收器提供资源的标志。在提供资源之前，应用无法启动。该标志表示&amp;ndash;alsa-check-close-timeout=0。 6 &amp;ndash;account-consistency 用于启用帐户一致性的命令行标志。默认模式已禁用。镜像是一种传统模式，其中 Google 帐户始终会添加到 Chrome，然后 Chrome 会将其添加到 Google 身份验证 Cookie 中。骰子是一项新的实验，Chrome 可以识别 Google 身份验证 Cookie 中的帐户。 7 &amp;ndash;agc-startup-min-volume 覆盖与 getUserMedia 中的音轨一起使用的 WebRTC 中的自动增益控制算法的默认最小起始音量。有效范围是 12-255。超出该范围的值将被限制在 WebRTC 内的最低或最高有效值。 8 &amp;ndash;allow-cross-origin-auth-prompt 允许页面中包含的第三方内容提示输入 HTTP 基本身份验证用户名/密码对。 9 &amp;ndash;allow-external-pages 允许在布局测试期间访问外部页面。 10 &amp;ndash;allow-failed-policy-fetch-for-test 如果传递此标志，则失败的策略提取不会导致配置文件初始化失败。这对测试很有用，因为这意味着测试不必模拟策略基础结构。 11 &amp;ndash;allow-file-access-from-files 默认情况下，file://URIs 无法读取其他 file://URI。这是对需要旧行为进行测试的开发人员的覆盖。 12 &amp;ndash;allow-hidden-media-playback 允许媒体播放隐藏的 Web 内容 13 &amp;ndash;allow-http-background-page 允许托管应用的 background_page 的非 https 网址。 14 &amp;ndash;allow-http-screen-capture 允许非安全源使用屏幕捕获 API 和 desktopCapture 扩展 API。 15 &amp;ndash;allow-insecure-localhost 允许忽略 localhost 上的 TLS/SSL 错误（无插页式，不阻止请求）。 16 &amp;ndash;allow-legacy-extension-manifests 允许浏览器加载缺少现代清单的扩展，否则将被禁止。 17 &amp;ndash;allow-loopback-in-peer-connection 允许在网络列表中添加环回接口以进行对等连接。 18 &amp;ndash;allow-nacl-crxfs-api 指定以逗号分隔的扩展 ID 或主机列表，以授予对 CRX 文件系统 API 的访问权限。 19 &amp;ndash;allow-nacl-file-handle-api 指定以逗号分隔的扩展 ID 或主机列表，以授予对文件句柄 API 的访问权限。 20 &amp;ndash;allow-nacl-socket-api 指定以逗号分隔的扩展 ID 或主机列表，以授予对 TCP/UDP 套接字 API 的访问权限。 21 &amp;ndash;allow-no-sandbox-job 使沙箱进程能够在不分配作业对象的情况下运行。需要此标志才能允许 Chrome 在 RemoteApps 或 Citrix 中运行。此标志可以降低沙盒进程的安全性，并允许它们执行某些 API 调用，如关闭 Windows 或访问剪贴板。此外，我们失去了杀死某些进程的机会，直到拥有它们的外部作业完成。 22 &amp;ndash;allow- ted-plugins 23 &amp;ndash;allow-ra-in-dev-mode 允许在开发模式下进行远程证明（RA）以进行测试。通常 RA 在开发模式下被禁用，因为它总是会失败。但是，在测试的情况下，即使在开发模式下我们也希望通过权限流程。这个标志可以启用此功能。 24 &amp;ndash;allow-running-insecure-content 默认情况下，https 页面无法从 httpURL 运行 JavaScript，CSS 或插件。这提供了一个覆盖来获取旧的不安全行为。 25 &amp;ndash;allow-sandbox-debugging 允许调试沙盒进程。 26 &amp;ndash;allow-silent-push 允许不显示通知的 Web 推送通知。 27 &amp;ndash;alsa-check-close-timeout 当没有剩余混频器输入时，在关闭 PCM 手柄之前等待的时间（以 ms 为单位）。如果&amp;ndash;accept-resource-provider 存在，则假定为 0。 28 &amp;ndash;alsa-enable-upsampling 标志，可以重新采样音频，采样率低于 32kHz，最高可达 48kHz。对于内部音频产品，应设置为 true。 29 &amp;ndash;alsa-fixed-output-sample-rate 可选标志，用于为 alsa 设备设置固定的采样率。 30 &amp;ndash;alsa-input-device 打开音频输入流时使用的 Alsa 设备。 31 &amp;ndash;alsa-mute-device-name 应打开静音混音器的设备名称。如果未指定此标志，则它将默认为与 kAlsaVolumeDeviceName 相同的设备。 32 &amp;ndash;alsa-mute-element-name 基于 ALSA 的媒体库用于静音系统的简单混音器控制元素的名称。 33 &amp;ndash;alsa-output-avail-min 用于安排传输的最小可用帧数。 34 &amp;ndash;alsa-output-buffer-size ALSA 输出缓冲区的大小（以帧为单位）。这直接设置输出设备的延迟。可以通过将采样率乘以输出缓冲区大小来计算延迟。 35 &amp;ndash;alsa-output-device 打开音频流时使用的 Alsa 设备。 36 &amp;ndash;alsa-output-period-size ALSA 输出周期的大小（以帧为单位）。ALSA 输出设备的周期确定硬件中断之间经过的帧数。 37 &amp;ndash;alsa-output-start-threshold 输出开始前输出缓冲区中需要多少帧。 38 &amp;ndash;alsa-volume-device-name 应打开音量控制混音器的设备名称。如果没有提供 kAlsaOut 39 &amp;ndash;alsa-volume-element-name 基于 ALSA 的媒体库用于控制音量的简单混音器控制元素的名称。 40 &amp;ndash;also-emit-success-logs 还会发出完整事件跟踪日志以进行成功测试 41 &amp;ndash;alternative 数据缩减代理使用 Chrome-Proxy“exp”指令值来接收备用后端实现。 42 &amp;ndash;always-authorize-plugins 防止 Chrome 需要授权才能运行某些广泛安装但不太常用的插件。 43 &amp;ndash;always-use-complex-text 始终使用复杂的文本路径进行布局测试。 44 &amp;ndash;android-fonts-path 在 linux 上使用 androidSkFontManager。指定的目录应包含名为“fonts.</description>
    </item>
    
    <item>
      <title>Jenkins 编译Android apk 流水线</title>
      <link>/posts/work/gradle-apk/</link>
      <pubDate>Fri, 25 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/gradle-apk/</guid>
      <description>背景 Jenkins 编译 Android apk，上传 apk 包，生成下载二维码，并推送钉钉
安装 Android 环境 安装 JDK # 这里使用的是openjdk 1.8.0版本，有需要的话需要到java官网上进行下载对应的JDK版本。 $ yum install java -y # 其他版本JDK的安装方式 $ mv jdk1.8.0_161 /usr/local/ $ ln -s /usr/local/jdk1.8.0_161 /usr/local/jdk $ vim /etc/profile #配置JDK的环境变量 export JAVA_HOME=/usr/local/jdk export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar $ source /etc/profile #重新加载系统环境变量 $ java -version #查看java版本 Android SDK 安装 # 下载sdk工具包 $ wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip # 创建sdk工具文件夹和解压工具包 $ mkdir -p /opt/android/sdk $ unzip sdk-tools-linux-3859397.zip -d /opt/android/sdk # 使用sdkmanager工具配置构建工具和平台版本 $ cd /opt/android/sdk/tools/bin/ $ .</description>
    </item>
    
    <item>
      <title>Nexus3 使用和部署</title>
      <link>/posts/work/nexus/</link>
      <pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/nexus/</guid>
      <description>Nexus3 docker-compose 安装 创建外部存储
mkdir -p /data/nexus chmod +777 -R /data/nexus 运行 docker-compose
version: &amp;#39;3&amp;#39; services: nexus3: image: sonatype/nexus3:3.42.0 container_name: nexus3 ports: - 8081:8081 - 5000:5000 volumes: - /data/nexus:/nexus-data environment: - INSTALL4J_ADD_VM_PARAMS=-Xms1024m -Xmx1024m -XX:MaxDirectMemorySize=1024m -Djava.util.prefs.userRoot=/some-other-dir restart: always # 赋予外部root权限 privileged: true docker-compose up -d 运行 docker-compose</description>
    </item>
    
    <item>
      <title>shell 脚本（1）</title>
      <link>/posts/work/shell1/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/shell1/</guid>
      <description>shell 脚本之变量 变量替换 语法 说明 ${变量名#匹配规则} 从变量开头进行规则匹配，将符合最短的数据删除 ${变量名##匹配规则} 从变量开头进行规则匹配，将符合最长的数据删除 ${变量名%匹配规则} 从变量尾部进行规则匹配，将符合最短的数据删除 ${变量名%%匹配规则} 从变量尾部进行规则匹配，将符合最长的数据删除 ${变量名/旧字符串/新字符串} 变量内容符合旧字符串则，则第一个旧字符串会被新字符串取代 ${变量名//旧字符串/新字符串} 变量内容符合旧字符串则，则全部的旧字符串会被新字符串取代 字符串处理 计算字符串长度 - 语法 说明 方法一 ${#string} 无 方法二 expr length &amp;ldquo;$string&amp;rdquo; string 有空格，则必须加双引号 获取子串在字符串中的索引位置
语法： expr index $string $substring
计算子串长度
语法： expr match $string substr
抽取子串
${string:position} ：从 string 中的 position 开始 ${string:position:length}：从 position 开始，匹配长度为 length ${string:-position}：从右边开始匹配 ${string:(position)}：从左边开始匹配 expr substr $string $position $length：从 position 开始，匹配长度为 length </description>
    </item>
    
    <item>
      <title>Maven 安装编译</title>
      <link>/posts/work/maven/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/maven/</guid>
      <description>Maven 安装编译 Maven 就是专门为 Java 项目打造的管理和构建工具，它的主要功能有：
提供了一套标准化的项目结构； 提供了一套标准化的构建流程（编译，测试，打包，发布……）； 提供了一套依赖管理机制。 默认结构：
a-maven-project ├── pom.xml ├── src │ ├── main │ │ ├── java │ │ └── resources │ └── test │ ├── java │ └── resources └── target 项目的根目录a-maven-project是项目名，
它有一个项目描述文件pom.xml，
存放Java源码的目录是src/main/java，
存放资源文件的目录是src/main/resources，
存放测试源码的目录是src/test/java，
存放测试资源的目录是src/test/resources，
最后，所有编译、打包生成的文件都放在target目录里。
这些就是一个 Maven 项目的标准目录结构。
pom.xml 文件:
&amp;lt;project ...&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.itranswarp.learnjava&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hello&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;properties&amp;gt; ... &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt; groupId类似于 Java 的包名，通常是公司或组织名称，</description>
    </item>
    
    <item>
      <title>Nodejs 安装编译</title>
      <link>/posts/work/nodejs/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/nodejs/</guid>
      <description>Nodejs 安装编译 Node.js 平台是在后端运行 JavaScript 代码，必须首先在本机安装 Node 环境。
安装 Node.js 安装 npm npm 其实是 Node.js 的包管理工具（package manager）。</description>
    </item>
    
    <item>
      <title>ruoyi-cloud docker部署</title>
      <link>/posts/work/ruoyi/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/work/ruoyi/</guid>
      <description>基础环境安装 # docker 脚本安装 curl -sSL https://get.daocloud.io/docker | sh #docker compose 脚本安装 curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-compose #可执行权限 sudo chmod +x /usr/local/bin/docker-compose #创建软链： sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose #测试是否安装成功 docker-compose --version 下载安装 git clone https://gitlab.sanjiang.com/it-group/ruoyi-cloud.git 编译 cd ruoyi-cloud mvn clean install -DskipTests 复制 jar 包 cd ./docker ./copy.sh 部署 docker ./deploy.sh base ./deploy.sh modules 检查 docker docker ps -a | grep ruoyi docker logs -f ruoyi-auth docker logs -f ruoyi-gateway docker logs -f ruoyi-modules-system </description>
    </item>
    
  </channel>
</rss>
